(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?factory(exports):typeof define==="function"&&define.amd?define(["exports"],factory):(global=global||self,factory(global.files={}))})(this,function(exports){"use strict";const fs=require("fs");const path=require("path");const{homedir:homedir,tmpdir:tmpdir}=require("os");const{promisify:promisify}=require("util");const swear=require("swear");const run=require("atocha");const mac=()=>process.platform==="darwin";const linux=()=>process.platform==="linux";const abs=(name=".",base=process.cwd())=>swear((async()=>{name=await name;base=await base;if(path.isAbsolute(name))return name;if(!base||typeof base!=="string"){base=process.cwd()}return join(base,name)})());const readFile=file=>promisify(fs.readFile)(file,"utf-8");const cat=name=>swear(abs(name).then(readFile).catch(err=>""));const dirFlat=file=>path.dirname(file);const dir=name=>swear(abs(name).then(dirFlat));const existsAsync=promisify(fs.exists);const existsFlat=file=>existsAsync(file);const exists=name=>swear(abs(name).then(existsFlat).catch(res=>res));const home=(...args)=>swear(join(homedir(),...args).then(mkdir));const joinFlat=parts=>path.join(...parts);const join=(...parts)=>abs(swear(parts).then(joinFlat));const list=dir=>{const readDir=promisify(fs.readdir);return swear([dir]).map(abs).map(file=>readDir(file)).shift().map(file=>abs(file,dir))};const mkdirAsync=promisify(fs.mkdir);const mkdir=name=>swear(abs(name).then(async file=>{return swear(file.split(path.sep).map((part,i,all)=>{return all.slice(0,i+1).join(path.sep)}).filter(Boolean).reduce((prom,path)=>{return prom.then(async()=>await exists(path)?path:mkdirAsync(path)).catch(err=>{}).then(()=>file)},Promise.resolve()))}));const name=file=>swear(swear(file).then(path.basename));const removeDirAsync=promisify(fs.rmdir);const removeFileAsync=promisify(fs.unlink);const remove=name=>swear(abs(name).then(async file=>{if(file==="/")throw new Error("Cannot remove the root folder `/`");if(!await exists(file))return file;if(await stat(file).isDirectory()){const files=await walk(file).map(remove);await list(file).map(remove);await removeDirAsync(file).catch(err=>{});return file}await removeFileAsync(file).catch(err=>{});return file}));const statAsync=promisify(fs.lstat);const stat=name=>swear(abs(name).then(statAsync).catch(err=>{}));const tmp=(...args)=>abs(join(tmpdir(),...args).then(mkdir));const rWalk=name=>{const file=abs(name);const deepper=async file=>{if((await stat(file)).isDirectory()){return rWalk(file)}return[file]};return list(file).map(deepper).reduce((all,arr)=>all.concat(arr),[])};const walk=name=>swear(exists(name).then(async isThere=>{if(!isThere)return swear([]);if(linux()||mac()){try{const result=await run(`find ${await abs(name)} -type f`);return result.split("\n").filter(Boolean)}catch(error){}}return rWalk(abs(name)).filter(Boolean)}));const writeAsync=promisify(fs.writeFile);const write=(name,body="")=>swear(abs(name).then(async file=>{await writeAsync(file,body);return file}));var files={abs:abs,cat:cat,dir:dir,exists:exists,home:home,join:join,list:list,ls:list,mkdir:mkdir,name:name,read:cat,remove:remove,stat:stat,tmp:tmp,walk:walk,write:write};exports.abs=abs;exports.cat=cat;exports.default=files;exports.dir=dir;exports.exists=exists;exports.home=home;exports.join=join;exports.list=list;exports.ls=list;exports.mkdir=mkdir;exports.name=name;exports.read=cat;exports.remove=remove;exports.stat=stat;exports.tmp=tmp;exports.walk=walk;exports.write=write;Object.defineProperty(exports,"__esModule",{value:true})});